#Pay a visit to your Local Library

At this point you're probably used to hunting through binaries for useful
functions or code that you can use to get a shell. But what do you do without a
call to `system()`?

The simple answer: get a shell anyways. :)

The long answer is a bit more complicated. This attack is called a return to
libc, or ret2libc for short. If you don't remember the PLT and GOT from before,
now is a good time to check the [glossary](../terms) and maybe do some
googling. You'll recall that ASLR randomizes the libc address, but the good
news is that with arbitrary `read()` and `write()` you can easily circumvent
this.

This binary has what we call Dynamic Input, which is some super fancy
ego-inflating jargon that means we can change inputs in the same program.
Basically any program where you can trigger the vulnerability twice (or more) with
different exploits in the same run is dynamic. If it still doesn't make sense,
just stay tuned.

If you haven't already, run through [Exercise 3.5: Intro to pwntools](../exercise-3.5)

Seriously, go do that.

Now that you've made it this far, I'll give a brief overview of this style of
exploit. The libc functions that the PLT stubs call aren't just some magical
ethereal functions. They're real and they're mapped to a real page in memory
with an address that you can call if you're clever. **The entire libc is in
the binary.** From here, we exploit the fact that truly randomizing everything
is computationally expensive. Instead, ASLR only randomizes the **base
address** of the libc. This means that &function_1 - &function_2 is constant as
long as you're using the same libc file. With this in mind, the goal is to leak
(`write()`) the address of some libc function to stdout. we then take that
address, compute the address of system, call `main()` (or whatever function
contains the vulnerability) again, and call `system()` with the newly computed
address.

Still confused? I was when I first learned this, but I'll try to explain as I go.


First, we have to calculate the offset of `%eip`
```
$ python -c 'print "A"*140 + "BBBB"' | strace ./exercise-4
...
--- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x42424242} ---
```

After 140 bytes, we have `%eip`

From here, we need to leak the address of a libc function.


